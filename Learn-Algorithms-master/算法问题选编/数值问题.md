

写一个函数，检查字符是否是整数，如果是，返回其整数值

类似的题目还有：
怎样只用4行代码编写出一个从字符串到长整形的函数？
请编写能直接实现int atoi(const char * pstr)函数功能的代码。  将字符串转出整数

分析：
使用递归实现
int string_to_integer(char *s,int length)
单要思考几个问题：
1. s是空字符串
2. s传参为非数字字符
3. 超出整数所能表示范围




题目：求1+2+…+n，
要求不能使用乘除法、for、while、if、else、switch、case等关键字以及条件判断语句（A?B:C）。

分析：
1. 不能使用循环，那就用递归
2. 递归需要终止递归的条件判断语句，这里也不能用if,想其他办法，可以使用 &&逻辑与 运算符（在n>0条件满足是，才会指向后面的递归语句


int factorial(n){
    int sum=0;
    (n>0) && sum=n+factorial(n-1)
    return sum;
}




整数的二进制表示中1的个数
题目：输入一个整数，求该整数的二进制表达中有多少个1。
例如输入10，由于其二进制表示为1010，有两个1，因此输出2。

分析：
这是一道很基本的考查位运算的面试题。
解法1：一轮循环移位计数 （移位运算比除法运算效率要高,注意要考虑是负数的情况）
解法2：位运算
解法3：num &= num-1  巧妙之处在于，对高位没有影响。不断做 `num &= num-1` 直到num=0




请定义一个宏，比较两个数a、b的大小，不能使用大于、小于、if语句

分析：
#define min(a,b) （(a)>(b)?(a):(b)）
#define MIN(A,B) ({ __typeof__(A) __a = (A); __typeof__(B) __b = (B); __a < __b ? __a : __b; })

这里不能使用比较符号：

#define min(a,b) ((a)-(b) & (0x1<<31))?(a):(b)





编程实现：把十进制数(long型)分别以二进制和十六进制形式输出，不能使用printf系列

分析：
char *integer_to_hex(long i);
char *integer_to_bin(long i);

注意，转16进制中，要判断tmp[i]是否是有符号的数
tmp[i]= tmp[i]>=0?tmp[i]:tmp[i]+16;






判断一个自然数是否是某个数的平方。说明：当然不能使用开方运算。

square(25) YES
square(35) NO

方法1： 从1开始遍历，显然这种方法很差
方法2： 除数跟余数比较，除数从2开始,每一轮都跟结果比较；相等就是存在这个数，不相等就把除数++；时间复杂度为（根号n）。在一个数比较大时，效率不够好。如1194877489=（34567）^2,需要从2开始，一直比较到34566，做3万多次除法和比较运算。跟方法1一样。。

方法3：二分查找 O(logn)




1024! 末尾有多少个0？

分析：
末尾0的个数取决于2和5的个数
能被2整除的数比能被5整除的数要多得多，因此只统计被5整除的数的个数
？？





编程实现两个正整数的除法(和取模)
编程实现两个正整数的除法，当然不能用除法操作符。
// return x/y.
int div(const int x, const int y) 
{}

1. 循环减被除数，减到不能再减，当除数很大，被除数小时，效率很低
2. 位运算





求两个或N个数的最大公约数和最小公倍数。




大整数乘法（或 大整数阶乘）
请使用代码计算1234567891011121314151617181920*2019181716151413121110987654321 。

1. 注意结果可能超出长整形的最大范围 2^64-1
2. 采用分治算法，将大整数相乘转换为小整数计算

规律分析：
任意位数的整数相乘，最终都可以转化为2位数相乘




两个数相乘，小数点后位数没有限制，请写一个高精度算法






如何求根号2的值，并且按照我的需要列出指定小数位，比如根号2是1.141 我要列出1位小数就是1.1 2位就是1.14， 1000位就是1.141...... 等。。

分析：
泰勒级数
牛顿迭代法










58、整数的素数和分解问题

歌德巴赫猜想说任何一个不小于6的偶数都可以分解为两个奇素数之和。
对此问题扩展，如果一个整数能够表示成两个或多个素数之和，则得到一个素数和分解式。

对于一个给定的整数，输出所有这种素数和分解式。
注意，对于同构的分解只输出一次（比如5只有一个分解2 + 3，而3 + 2是2 + 3的同构分解式

）。

例如，对于整数8，可以作为如下三种分解：
(1) 8 = 2 + 2 + 2 + 2
(2) 8 = 2 + 3 + 3
(3) 8 = 3 + 5





在从1到n的正数中1出现的次数
题目：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。

例如输入12，从1到12这些整数中包含1 的数字有1，10，11和12，1一共出现了5次。
分析：这是一道广为流传的google面试题。

int one_appear_count(int n);
思路1. 遍历1~n，统计出现1的个数；n足够大时，效率很低
思路2. 分析规律





排列组合问题
1，2，3，4，5 五个不同的数字，打印不同的排列
这就是一个无向图的遍历，把每个数字看成一个节点。


用1、2、2、3、4、5这六个数字，写一个main函数，打印出所有不同的排列，
如：512234、412345等，要求："4"不能在第三位，"3"与"5"不能相连.

这是对上一题增加难度。但是需要
1. 去掉 3，5之间的联通
2. 2重复，过滤重复结果  treeset
3. 4不能在3位






给定一个集合A=[0,1,3,8](该集合中的元素都是在0，9之间的数字，但未必全部包含)，
指定任意一个正整数K，请用A中的元素组成一个大于K的最小正整数。

比如，A=[1,0] K=21 那么输出结构应该为100。




20、给定能随机生成整数1到5的函数，写出能随机生成整数1到7的函数。



给你5个球，每个球被抽到的可能性为30、50、20、40、10，设计一个随机算法，该算法的输出结果为本次执行的结果。输出A，B，C，D，E即可。


2.已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，
使得它构造0和1的概率均为1/2；构造一个发生器，使得它构造1、2、3的概率均为1/3；...，
构造一个发生器，使得它构造1、2、3、...n的概率均为1/n，要求复杂度最低。









两个圆相交，交点是A1，A2。现在过A1点做一直线与两个圆分别相交另外一点B1，B2。B1B2可以绕着A1点旋转。问在什么情况下，B1B2最长




题目：输入四个点的坐标，求证四个点是不是一个矩形
关键点：
1.相邻两边斜率之积等于-1，
2.矩形边与坐标系平行的情况下，斜率无穷大不能用积判断。
3.输入四点可能不按顺序，需要对四点排序。


矩阵式螺旋输出

    









